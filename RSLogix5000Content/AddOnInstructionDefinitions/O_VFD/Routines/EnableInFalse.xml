<?xml version="1.0" encoding="utf-8"?>
<Routine Name="EnableInFalse" Type="RLL">
  <RLLContent>
    <Rung Type="N">
      <Comment><![CDATA[======================================================================================
AOI Initialization
======================================================================================
On initial instantiation, power-up, or transition from Program-to-Run, Sts_InitDone
is cleared and the next few rungs (prior to the Continue Label) execute. The
Sts_InitDone flag is set at the end of the Logic routine once it has executed once.]]></Comment>
      <Text><![CDATA[XIC(S:FS)OTU(wrkInitDone);]]></Text>
    </Rung>
    <Rung Type="N">
      <Text><![CDATA[XIC(wrkInitDone)JMP(Continue);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[======================================================================================
Local Operating Device Ownership
======================================================================================
The P_CmdSrc AOI determines how inputs and commands affect device operation. Under
normal operating conditions commands may be received from either a Program Owner as
generated by application logic, or an Operator Owner directly from an HMI. There are
also four exception conditions that transcend the Program/Operator Ownership: Hand, 
Out-of-Service, Maintenance, and Override.
Five configuration options are provided:
	No Prog (Cfg_Owner = 4): Operator-only ownership. The P_CmdSrc AOI only
		presents Sts_Oper as the non-exception owner.
	No Oper (Cfg_Owner = 3): Program-only ownership. The P_CmdSrc AOI only
 		presents Sts_Prog as the non-exception owner.
	Prog/Oper Level (Cfg_Owner = 2): Control Prog/Oper selection using PCmd_Lock 
		as a level command (1=Sts_ProgLocked, 0=Sts_Oper).
	No Oper Lock (Cfg_Owner = 1): Prevent Operator owner from applying an ownership lock.
	Normal (Cfg_Owner = 0): The P_CmdSrc AOI presents all four operating ownership
                states: Sts_Oper/Sts_OperLocked.Sts_Prog/Sts_ProgLocked.

NOTE - The ownership configuration is read on first-scan only. Ownership functionality
       will not change if Cfg_Owner is modified while in operation.]]></Comment>
      <Text><![CDATA[[MOVE(Cfg_Owner,wrkCfgOwner) [GT(wrkCfgOwner,4) ,LT(wrkCfgOwner,0) ] CLR(wrkCfgOwner) ,EQ(wrkCfgOwner,0) [OTL(CmdSrc.Cfg_HasOper) OTL(CmdSrc.Cfg_HasOperLocked) OTL(CmdSrc.Cfg_HasProg) OTL(CmdSrc.Cfg_HasProgLocked) ,OTU(CmdSrc.Cfg_PCmdLockAsLevel) OTU(CmdSrc.Cfg_ProgNormal) ] ,EQ(wrkCfgOwner,1) [OTL(CmdSrc.Cfg_HasOper) OTU(CmdSrc.Cfg_HasOperLocked) OTL(CmdSrc.Cfg_HasProg) OTL(CmdSrc.Cfg_HasProgLocked) ,OTU(CmdSrc.Cfg_PCmdLockAsLevel) OTU(CmdSrc.Cfg_ProgNormal) ] ,EQ(wrkCfgOwner,2) [OTL(CmdSrc.Cfg_HasOper) OTU(CmdSrc.Cfg_HasOperLocked) OTU(CmdSrc.Cfg_HasProg) OTL(CmdSrc.Cfg_HasProgLocked) ,OTL(CmdSrc.Cfg_PCmdLockAsLevel) OTU(CmdSrc.Cfg_ProgNormal) ] ,EQ(wrkCfgOwner,3) [OTU(CmdSrc.Cfg_HasOper) OTU(CmdSrc.Cfg_HasOperLocked) OTL(CmdSrc.Cfg_HasProg) OTU(CmdSrc.Cfg_HasProgLocked) ,OTU(CmdSrc.Cfg_PCmdLockAsLevel) OTL(CmdSrc.Cfg_ProgNormal) ] ,EQ(wrkCfgOwner,4) [OTL(CmdSrc.Cfg_HasOper) OTU(CmdSrc.Cfg_HasOperLocked) OTU(CmdSrc.Cfg_HasProg) OTU(CmdSrc.Cfg_HasProgLocked) ,OTU(CmdSrc.Cfg_PCmdLockAsLevel) OTU(CmdSrc.Cfg_ProgNormal) ] ,OTL(CmdSrc.Cfg_HasMaint) OTL(CmdSrc.Cfg_OvrdOverLock) OTL(CmdSrc.Cfg_PCmdPriority) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
MODE PROCESSING
============================================================
This rung handles received Mode Inputs and Commands:

NOTE:  All Commands for Mode, Alarm are aliased directly to the
corresponding Commands in the contained P_Mode and P_Alarm AOIs.]]></Comment>
      <Text><![CDATA[LBL(Continue)MOVE(wrkCfgOwner,Cfg_Owner)raM_Opr_CmdSrc(CmdSrc);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA["Lurking" Program Commands are cleared if they are set as "Edge" triggered
(cleared by this object as received).
(Lurking Acknowledge Commands are left to perform their action.)]]></Comment>
      <Text><![CDATA[OTU(PCmd_Start)OTU(PCmd_Stop)OTU(PCmd_Fwd)OTU(PCmd_Rev);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA["Lurking" Operator Commands are cleared, as well as Program Reset.]]></Comment>
      <Text><![CDATA[[OTU(OCmd_Start) OTU(OCmd_Stop) OTU(OCmd_Jog) ,OTU(OCmd_Fwd) OTU(OCmd_Rev) ,OTU(Rdy_Start) OTU(Rdy_Stop) OTU(Rdy_Jog) ,OTU(Rdy_Fwd) OTU(Rdy_Rev) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[Outputs are cleared on Prescan.]]></Comment>
      <Text><![CDATA[[OTU(Out_Start) OTU(Out_Run) ,OTU(Out_Jog) OTU(Out_Rev) ,OTU(wrkJog) CLR(Out_SpdRefIO) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[These rungs get Configuration data (such as timer presets) and distribute as needed.
Note that some Configuration data are used directly in-place.

Enter the time (in seconds) for the Drive to successfully start before declaring a fault.
Enter the time (in seconds) for the Drive to successfully stop before declaring a fault.
Enter the time (in seconds) for the Drive Fault Reset output to be pulsed when a reset is received.
(The reset pulse time is also used for pulsing Start or Stop
output on a start or stop command retrigger in Maintenance.)

If the timer preset calcuated wraps negative (more than 2.14... million seconds), then max out the
or clear the Timer Preset (as appropriate) and flag it.  Note that a negative timer preset will fault the controller!!!

#####  V3.1-04 Patch01  2015-09-25:  Modified to correct issue with loss of run feedback.  #####]]></Comment>
      <Text><![CDATA[[MUL(Cfg_FailToStartT,1000,wrkStartFailTmr.PRE) XIC(wrkStartFailTmr.PRE.31) OTU(wrkStartFailTmr.PRE.31) ,MUL(Cfg_FailToStopT,1000,wrkStopFailTmr.PRE) XIC(wrkStopFailTmr.PRE.31) OTU(wrkStopFailTmr.PRE.31) ,MUL(Cfg_ResetPulseT,1000,wrkResetTmr.PRE) XIC(wrkResetTmr.PRE.31) OTU(wrkResetTmr.PRE.31) ,MUL(Cfg_MaxJogT,1000,wrkJogTmr.PRE) XIC(wrkJogTmr.PRE.31) OTU(wrkJogTmr.PRE.31) ]OTE(Err_Timer);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[This rung handles the reports of all Bad Configuration Status.
Individual bits are provided for various status:
Bad Raw Scaling configs
Bad Engineering Units Scaling configs
Bad Min or Max Speed Reference clamp limit
Bad simulation speed ramp time
Bad timer config from (rung above)
Bad Alarm config (from P_Alarm)
Bad Cfg_OperKeep / Cfg_ProgKeep config

Then a summary Bad Config status is provided, simply an OR of the individual bits.

#####  V3.0-00  2013-06-30:   Added Cfg_HasSpeedFdbk  #####]]></Comment>
      <Text><![CDATA[[EQ(Cfg_SpdFdbkMaxIO,Cfg_SpdFdbkMinIO) OTE(Err_FdbkIO) ,EQ(Cfg_SpdFdbkMax,Cfg_SpdFdbkMin) OTE(Err_FdbkEU) ,EQ(Cfg_SpdRefMax,Cfg_SpdRefMin) OTE(Err_RefEU) ,EQ(Cfg_SpdRefMaxIO,Cfg_SpdRefMinIO) OTE(Err_RefIO) ,LE(Cfg_SpdRefHLim,Cfg_SpdRefLLim) OTE(Err_RefLim) ,XIC(Err_Timer) ]OTE(Sts_ER);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[This rung publishes the Values for the scaled speed reference range.
If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,
the values are swapped so the the EUMax Value is always greater than the EUMin Value.
This makes the HMI bargraph and trend coding easier, and provides values
that can be pinned to the configuration of another block so the VSD's range
 and other block's range are in lockstep.]]></Comment>
      <Text><![CDATA[[GE(Cfg_SpdRefMax,Cfg_SpdRefMin) MOVE(Cfg_SpdRefMin,Val_SpdRefMin) MOVE(Cfg_SpdRefMax,Val_SpdRefMax) ,LT(Cfg_SpdRefMax,Cfg_SpdRefMin) MOVE(Cfg_SpdRefMin,Val_SpdRefMax) MOVE(Cfg_SpdRefMax,Val_SpdRefMin) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[This rung publishes the Values for the scaled speed feedback range.
If this instruction is reverse scaled by reversing the scaled (EU) min and max configurations,
the values are swapped so the the EUMax Value is always greater than the EUMin Value.
This makes the HMI bargraph and trend coding easier, and provides values
that can be pinned to the configuration of a PID, so the VSD and PID ranges are in lockstep.]]></Comment>
      <Text><![CDATA[[GE(Cfg_SpdFdbkMax,Cfg_SpdFdbkMin) MOVE(Cfg_SpdFdbkMin,Val_SpdFdbkMin) MOVE(Cfg_SpdFdbkMax,Val_SpdFdbkMax) ,LT(Cfg_SpdFdbkMax,Cfg_SpdFdbkMin) MOVE(Cfg_SpdFdbkMin,Val_SpdFdbkMax) MOVE(Cfg_SpdFdbkMax,Val_SpdFdbkMin) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
ALARM RESET COMMAND HANDLING
============================================================
This rung handles the Alarm Reset Input and Commands
and the "Reset and Ack All" Operator Command.

This rung processes received Reset Commands from:

1.  The Operator via HMI Operator Command, or
2.  Higher-level strategies via Program Command
3.  Pushbuttons or other block via Input
4.  Resets initiated by other device Operator Commands (if configured to do so)
and forwards the Reset to ALL Alarms and latched Shed conditions.

The reset starts the Reset Timer (One-Shot Off-Delay)
to ensure the output is held on for at least the minimum time.

#####  V3.1-00  2014-06-30: Added Not Ready reason bits (Nrdy_xxx)  #####
#####  V3.1-01  2014-08-29:  Corrections to Nrdy_ trip and reset logic.  #####]]></Comment>
      <Text><![CDATA[[XIC(OCmd_Reset) OTU(OCmd_Reset) ,XIC(PCmd_Reset) OTU(PCmd_Reset) ,XIC(Inp_Reset) ONS(wrkResetONS) ]TOF(wrkResetTmr,?,?);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
DRIVE FAIL TO STOP DETECTION
============================================================
If the drive SHOULD BE STOPPED, run a Stop Timer to check for Fail to Stop.

#####  V3.0-00  2013-06-30:  Modified for handling of local start/stop.  #####
#####  V3.1-04 Patch01  2015-09-25:  Modified to correct issue with loss of run feedback.  #####

@@@@@  The TON on the second branch is doubled to ensure it goes  @@@@@
@@@@@  true the same scan it is enabled if its preset is zero.  @@@@@]]></Comment>
      <Text><![CDATA[XIO(wrkRun)TON(wrkStopFailTmr,?,?);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[The Hold Timer "done" bit comes on immediately and stays on
for the hold time.  If it, or any held-on reset initiator, is TRUE, set the Output.]]></Comment>
      <Text><![CDATA[XIC(wrkResetTmr.DN)CLR(wrkNotRdy)XIC(Inp_DrvFlt)OTE(Out_ClrFlt);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
DRIVE READY TO RUN HANDLING
============================================================
The drive is NOT READY TO RUN if:
* Interlocks are not OK and not bypassed;
* Non-bypassable Interlocks are not OK;
* Permissives are not OK and not bypassed,
or Non-Bypassable Permissives are not OK, 
and the motor is not already starting or running;
* The drive (not simulated) reports that it is faulted;
* There's an I/O failure and the motor is NOT being simulated;
* The motor has a Fail to Start that has not been reset;
* The drive is disabled (by Maintenance);
* This instruction instance has a configuration error.

#####  V3.1-00  2014-06-30: Added Not Ready reason bits (Nrdy_xxx)  #####
#####  V3.1-01  2014-08-29:  Corrections to Nrdy_ trip and reset logic.  #####]]></Comment>
      <Text><![CDATA[[XIC(CmdSrc.Sts_OoS) OTE(Sts_OOS) ,XIC(CmdSrc.Sts_Ovrd) OTE(Sts_Ovrd) ,OTU(wrkNotRdy.3) ,XIC(Inp_DrvFlt) OTL(Flt_DriveFault) ,OTU(wrkNotRdy.5) ,XIC(Inp_IOFault) OTL(Flt_IOComm) ,XIC(wrkStopFailTmr.DN) XIC(Inp_DrvRun) OTL(Flt_FailToStop) ,[XIC(Flt_DriveFault) ,XIC(Flt_IOComm) ,XIC(Flt_FailToStart) ,XIC(Flt_FailToStop) ] OTE(Sts_Fault) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
DRIVE START / STOP COMMAND HANDLING
============================================================
The drive is NOT READY TO RUN if:
* Interlocks are not OK and not bypassed;
* Non-bypassable Interlocks are not OK;
* Permissives are not OK and not bypassed,
or Non-Bypassable Permissives are not OK, 
and the motor is not already starting or running;
* The drive (not simulated) reports that it is faulted;
* There's an I/O failure and the motor is NOT being simulated;
* The motor has a Fail to Start that has not been reset;
* The drive is disabled (by Maintenance);
* This instruction instance has a configuration error.

#####  V3.1-00  2014-06-30: Added Not Ready reason bits (Nrdy_xxx)  #####
#####  V3.1-01  2014-08-29:  Corrections to Nrdy_ trip and reset logic.  #####]]></Comment>
      <Text><![CDATA[NE(wrkNotRdy,0)OTE(Sts_NotRdy)OTE(Rdy_Reset);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[============================================================
SPEED FEEDBACK PROCESSING
============================================================
If not in simulation and scaling config is valid, the speed feedback is scaled from the raw Input.

If the drive provides no speed feedback:
1. If the drive is running, copy the working Speed Reference to the Speed Feedback
for display on the Graphic Symbol.  (Speed Feedback will be HIDDEN on the Faceplate!)
2.  If the drive is stopped, cllear the Speed Feedback to zero for display.

#####  V3.0-00  2013-06-30:  Added Cfg_HasSpeedFdbk  #####
#####  V3.0-05  2014-05-20:  Modified to prevent both Simulation  #####
#####  scaling bits from being set at the same time.  #####
#####  V3.1-04 Patch01  2015-09-25:  Added logic for Cfg_HasSpeedFdbk = 0  #####
]]></Comment>
      <Text><![CDATA[XIO(Err_FdbkIO)XIO(Err_FdbkEU)[CPT(Val_SpdFdbk,(Inp_SpdFdbkIO-Cfg_SpdFdbkMinIO)/(Cfg_SpdFdbkMaxIO-Cfg_SpdFdbkMinIO)*(Cfg_SpdFdbkMax-Cfg_SpdFdbkMin)+Cfg_SpdFdbkMin) ,XIC(Sts_Hand) CPT(wrkSpdRef,(Val_SpdFdbk-Cfg_SpdFdbkMin)/(Cfg_SpdFdbkMax-Cfg_SpdFdbkMin)*(Cfg_SpdRefMax-Cfg_SpdRefMin)+Cfg_SpdRefMin) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[If the Speed Feedback scaling config values are invalid, just clear
Val_SpeedFdbk and skip the actual speed feedback processing.

#####  V3.0-00  2013-06-30:   Added Cfg_HasSpeedFdbk  #####
#####  V3.1-04 Patch01  2015-09-25:  Moved (Cfg_HasSpeedFdbk = 0) processing to previous rung.  #####]]></Comment>
      <Text><![CDATA[[XIC(Err_FdbkIO) ,XIC(Err_FdbkEU) ]CLR(Val_SpdFdbk);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[Higher Priority: HAND wins over other Modes:
If in Hand, have the Drive follow the RunFeedback.]]></Comment>
      <Text><![CDATA[[XIC(Sts_Hand) ,XIO(wrkInitDone) ][XIO(Inp_DrvRev) OTU(Sts_Rev) ,XIC(Inp_DrvRev) OTL(Sts_Rev) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[If the drive is running (active) and Out-of-Service, issue a
STOP command. If in Hand Mode, have wrkRun track.]]></Comment>
      <Text><![CDATA[XIC(Inp_DrvRun)[XIO(Sts_Hand) OTE(Out_Stop) ,XIC(Sts_Hand) OTE(wrkRun) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[Check the selected speed reference against the configured Maximum and Minimum
allowed reference limits and ensure the speed is within limits.
Be sure the speed reference is not negative.  This object supports reversing
by command only; negative speed reference is NOT supported!]]></Comment>
      <Text><![CDATA[OTU(Sts_SpdLim)XIO(Sts_Hand)CLR(wrkSpdRef)[GT(wrkSpdRef,Cfg_SpdRefHLim) MOVE(Cfg_SpdRefHLim,wrkSpdRef) ,LT(wrkSpdRef,Cfg_SpdRefLLim) MOVE(Cfg_SpdRefLLim,wrkSpdRef) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[If the drive is NOT simulated and its scaling config is valid, scale the
final speed reference from engineering units to Raw (drive) Units.

If the drive is SIMULATED, set the Speed Reference output to ZERO.]]></Comment>
      <Text><![CDATA[MOVE(wrkSpdRef,Val_SpdRef)MOVE(wrkSpdRef,PSet_SpdRef)MOVE(wrkSpdRef,OSet_SpdRef);]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[This rung generates the Starting, Running, Stopping, Stopped and Jogging Status bits.

If the Drive is commanded to run (Output on) and the feedback doesn't yet show it running,
the Drive is STARTING.

If the Drive is commanded to run (Output on) and the feedback shows it running,
the Drive is RUNNING.

If the Drive is commanded to stoop (Output off) and the feedback still shows it running,
the Drive is STOPPING.

If the Drive is commanded to stop (Output off) and the feedback shows it has stopped,
the Drive is STOPPED.

#####  V3.0-00  2013-06-30:  Removed check of Cfg_UseRunFdbk --  #####
#####  now uses run feedback  based on speed fdbk  #####]]></Comment>
      <Text><![CDATA[[XIC(wrkRun) [XIO(Inp_DrvRun) OTE(Sts_Starting) ,XIC(Inp_DrvRun) OTE(Sts_Running) ] ,XIO(wrkRun) [XIC(Inp_DrvRun) OTE(Sts_Stopping) ,XIO(Inp_DrvRun) OTE(Sts_Stopped) ] ,OTU(Sts_Jog) OTU(Sts_AtSpd) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[Val_Sts is the current device status, as determined by this AOI,
based on its knowledge of commands executed and feedback.
(This is the status that should be monitored by, for example, FT Historian.)
0 = Powerup / Unknown (Hand Mode with no feedback, for example)
1 = Stopped
2 = Running Forward
3 = Running Reverse
4 = Jogging Forward
5 = Jogging Reverse
6 = Stopping
7 = Starting Forward
8 = Starting Reverse
33 = Device Disabled

Val_Fault is the current device fault status, as determined by this AOI,
based on its knowledge of commands executed and feedback.
(This is the fault status that should be monitored by, for example, FT Historian.)
0 = None
16 = Fail to Start
17 = Fail to Stop
18 = Drive Fault
34 = I/O Fault

Val_SrcQ is the current comm and configuration status.
0 = Cfg and Comm OK
34 = I/O Fault (from input)
35 = Configuration Error]]></Comment>
      <Text><![CDATA[[CLR(wrkSts) CLR(wrkFault) CLR(wrkSrcQ) ,XIC(Sts_Stopped) MOVE(1,wrkSts) ,XIC(Sts_Running) [XIO(Inp_DrvRev) MOVE(2,wrkSts) ,XIC(Inp_DrvRev) MOVE(3,wrkSts) ] ,XIC(Sts_Jog) [XIO(Inp_DrvRev) MOVE(4,wrkSts) ,XIC(Inp_DrvRev) MOVE(5,wrkSts) ] ,XIC(Sts_Stopping) MOVE(6,wrkSts) ,XIC(Sts_Starting) [XIO(Sts_Rev) MOVE(7,wrkSts) ,XIC(Sts_Rev) MOVE(8,wrkSts) ] ,XIC(wrkNotRdy.8) MOVE(16,wrkFault) ,XIC(Flt_FailToStop) MOVE(17,wrkFault) ,XIC(Flt_DriveFault) MOVE(18,wrkFault) ,XIC(Sts_OOS) MOVE(33,wrkSts) ,XIC(Flt_IOComm) MOVE(34,wrkFault) ,XIC(Inp_IOFault) MOVE(34,wrkSrcQ) ,XIC(Sts_ER) MOVE(35,wrkSrcQ) ,MOVE(wrkSts,Val_Sts) MOVE(wrkFault,Val_Fault) MOVE(wrkSrcQ,Val_SrcQ) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[If the drive is Faulted, this rung finds the Fault Description for
the given Fault Code within the Reference Fault Code List 
(In/Out Parameter).  (The same PF755 Fault Code List
can be referenced by ALL instances of this instruction!!!)

1.  Find the number of entries in the Fault Code List (Array SIZE).
2.  Search (FSC) the Fault Code List for a matching Code.
3.  If found, copy the corresponding Description to Val_FaultDesc.
4.  If NOT found, copy list entry zero ("No Help Available for this code").

And if the drive is not faulted, clear the Val_FaultDesc string.]]></Comment>
      <Text><![CDATA[XIC(Flt_DriveFault)ONS(wrkFaultONS)[RES(wrkFaultDescFSC) SIZE(Ref_FltCodeList,0,wrkFaultDescFSC.LEN) ,FSC(wrkFaultDescFSC,?,?,ALL,Ref_FltCodeList[wrkFaultDescFSC.POS].Code=Val_FaultCode) ,XIC(wrkFaultDescFSC.FD) COP(Ref_FltCodeList[wrkFaultDescFSC.POS].Desc,Val_FaultDesc,1) ,XIO(wrkFaultDescFSC.FD) COP(Ref_FltCodeList[0].Desc,Val_FaultDesc,1) ];]]></Text>
    </Rung>
    <Rung Type="N">
      <Comment><![CDATA[=================================================================
First scan through AOI Logic is complete. Set Sts_InitDone.
=================================================================]]></Comment>
      <Text><![CDATA[OTL(wrkInitDone);]]></Text>
    </Rung>
  </RLLContent>
</Routine>